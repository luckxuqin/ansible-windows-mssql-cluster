--- example SQL script
--- Creates a database 'myDB' with a 'myAG' avail group
--- Database files are in the data / logs directory as labeled by the OS


--- First, pick up the disk volume names for data and logs

-- Enable Ole Automation
EXECUTE sp_configure 'show advanced options', 1
RECONFIGURE WITH OVERRIDE
GO
EXECUTE sp_configure 'Ole Automation Procedures', 1
RECONFIGURE WITH OVERRIDE
GO

-- Create function for filesystem volumes
-- Credit: Percy Reyes

USE [master]
GO
CREATE FUNCTION [dbo].[ufn_LogicalDiskDrives]()
RETURNS @DriveList Table
  (
   [DriveLetter]  CHAR(1)
  ,[VolumeName]  VARCHAR(255)
  ,[FileSystem]  VARCHAR(50)
  )
AS

BEGIN
  DECLARE @DriveLetter_ASCII_Code  INT
  DECLARE @FileSystemInstance  INT
  DECLARE @DriveCount  INT
  DECLARE @DriveCollection  INT
  DECLARE @Drive  INT
  DECLARE @Property  NVARCHAR(100)    
  DECLARE @DriveLetter  VARCHAR(1)  
  DECLARE @FileSystem VARCHAR(128)
  DECLARE @VolumeName VARCHAR(128)
  DECLARE @IsReady VARCHAR(5)
  
  --Creating a File System Object for getting files or disk info.
  exec sp_OACreate 'Scripting.FileSystemObject', @FileSystemInstance OUT

  --Getting the collection of drives
  exec sp_OAGetProperty @FileSystemInstance,'Drives', @DriveCollection OUT

  --Getting the count of drives from collection
  exec sp_OAGetProperty @DriveCollection,'Count', @DriveCount OUT

  --starting from Drive "A" (ASCII 65) 
  SET @DriveLetter_ASCII_Code = 65
  --to "Z" (ASCII 90)
  WHILE @DriveLetter_ASCII_Code <= 90

  BEGIN

  -- Creating the instance drive from Drive Collection 
  SET @Property = 'item("'+CHAR(@DriveLetter_ASCII_Code)+'")'
  exec sp_OAGetProperty @DriveCollection,@Property, @Drive OUT

  -- Getting the drive letter property
  exec sp_OAGetProperty @Drive,'DriveLetter', @DriveLetter OUT

  IF @DriveLetter = CHAR(@DriveLetter_ASCII_Code)
    BEGIN   
    -- Getting more properties from each drive   
    exec sp_OAGetProperty @Drive,'VolumeName', @VolumeName OUT 
    exec sp_OAGetProperty @Drive,'FileSystem', @FileSystem OUT
    exec sp_OAGetProperty @Drive,'IsReady'  , @IsReady OUT; 
            
   IF @IsReady='True'
     INSERT INTO @DriveList ( [DriveLetter],[FileSystem],[VolumeName] )
     VALUES( @DriveLetter,@FileSystem,@VolumeName)
                             
   END
        -- forward next drive
        SET @DriveLetter_ASCII_Code = @DriveLetter_ASCII_Code +1
  END 
  
  EXEC sp_OADestroy @Drive 
  EXEC sp_OADestroy @DriveCollection

  RETURN
END
GO


-- set drive vars from function

DECLARE @log_drive NVARCHAR(50)
DECLARE @log_path NVARCHAR(50)
DECLARE @data_drive NVARCHAR(50)
DECLARE @data_path NVARCHAR(50)
DECLARE @dbName NVARCHAR(50);

-- set the databse name to "MyDB"
SET @dbName = N'MyDB';

select @log_drive = [DriveLetter]
from [dbo].[ufn_LogicalDiskDrives]()
where Volumename = 'logs'
set @log_path = @log_drive+":\" + @dbName + "_log.ldf"
print @log_path

select @data_drive = [DriveLetter]
from [dbo].[ufn_LogicalDiskDrives]()
where Volumename = 'data'
set @data_path =  @data_drive+":\" + @dbName + "_data.mdf"
print @data_path


-- Create the databse using the dbName defined above

-- Construct the SQL command
DECLARE @sql NVARCHAR(MAX);
SET @sql = N'
CREATE DATABASE ' + QUOTENAME(@dbName) + '
ON PRIMARY 
(
    NAME = ' + QUOTENAME(@dbName + '_Data') + ',
    FILENAME = ''' + @data_path + '''
)
LOG ON
(
    NAME = ' + QUOTENAME(@dbName + '_Log') + ',
    FILENAME = ''' + @log_path + '''
)';

-- Print the SQL command for debugging purposes
PRINT @sql;

-- Execute the SQL command
EXEC sp_executesql @sql;


-- Backup the DB created above 

DECLARE @backup_data_path NVARCHAR(50)
DECLARE @backup_log_path NVARCHAR(50)

set @backup_data_path =  @data_drive+":\" + @dbName +".bak"
set @backup_log_path =  @log_drive+":\" + @dbName +".log"

BACKUP DATABASE @dbName
TO DISK = @backup_data_path ;

BACKUP LOG @dbName 
TO DISK = @backup_log_path ;

GO


-- Now that we have a DB which is backed-up, an AG can be created


--- write connect argument to primary to file
:Out $(TEMP)\primary.temp
PRINT ':connect ' +  @@SERVERNAME + '';
GO
:Out stdout

--- write connect argument to first replica node
DECLARE @sec1 varchar(120) = (SELECT TOP 1 member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername);
:Out $(TEMP)\sec1.temp
PRINT ':connect ' +  @sec1 + '';
GO
:Out stdout

--- write connect argument to second replica node
DECLARE @sec2 varchar(120) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 1 ROWS FETCH NEXT 1 ROWS ONLY);

:Out $(TEMP)\sec2.temp
PRINT ':connect ' +  @sec2 + '';
GO
:Out stdout

--- write connect argument to third replica node
DECLARE @sec3 varchar(120) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 2 ROWS FETCH NEXT 1 ROWS ONLY);

:Out $(TEMP)\sec3.temp
PRINT ':connect ' +  @sec3 + '';
GO
:Out stdout

--- write connect argument to fourth replica node
DECLARE @sec4 varchar(120) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 3 ROWS FETCH NEXT 1 ROWS ONLY);

:Out $(TEMP)\sec4.temp
PRINT ':connect ' +  @sec4 + '';
GO
:Out stdout

--- create endpoint on primary
:r $(TEMP)\primary.temp

EXEC
	(N'USE [master]

    CREATE ENDPOINT [Hadr_endpoint] 
        AS TCP (LISTENER_PORT = 5022)
        FOR DATA_MIRRORING (ROLE = ALL, ENCRYPTION = REQUIRED ALGORITHM AES)

    IF (SELECT state FROM sys.endpoints WHERE name = N''Hadr_endpoint'') <> 0
    BEGIN
        ALTER ENDPOINT [Hadr_endpoint] STATE = STARTED
    END

    IF EXISTS(SELECT * FROM sys.server_event_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER WITH (STARTUP_STATE=ON);
    END
    IF NOT EXISTS(SELECT * FROM sys.dm_xe_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER STATE=START;
    END')

GO

--- create endpoint on first replica node
:r $(TEMP)\sec1.temp

EXEC
	(N'USE [master]

    CREATE ENDPOINT [Hadr_endpoint] 
        AS TCP (LISTENER_PORT = 5022)
        FOR DATA_MIRRORING (ROLE = ALL, ENCRYPTION = REQUIRED ALGORITHM AES)

    IF (SELECT state FROM sys.endpoints WHERE name = N''Hadr_endpoint'') <> 0
    BEGIN
        ALTER ENDPOINT [Hadr_endpoint] STATE = STARTED
    END

    IF EXISTS(SELECT * FROM sys.server_event_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER WITH (STARTUP_STATE=ON);
    END
    IF NOT EXISTS(SELECT * FROM sys.dm_xe_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER STATE=START;
    END')

GO

--- create endpoint on second replica node if exist
DECLARE @sec2 varchar(120) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 1 ROWS FETCH NEXT 1 ROWS ONLY);

:r $(TEMP)\sec2.temp

IF @sec2 IS NOT NULL EXEC 
	(N'USE [master]

    CREATE ENDPOINT [Hadr_endpoint] 
        AS TCP (LISTENER_PORT = 5022)
        FOR DATA_MIRRORING (ROLE = ALL, ENCRYPTION = REQUIRED ALGORITHM AES)

    IF (SELECT state FROM sys.endpoints WHERE name = N''Hadr_endpoint'') <> 0
    BEGIN
        ALTER ENDPOINT [Hadr_endpoint] STATE = STARTED
    END

    IF EXISTS(SELECT * FROM sys.server_event_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER WITH (STARTUP_STATE=ON);
    END
    IF NOT EXISTS(SELECT * FROM sys.dm_xe_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER STATE=START;
    END')

GO

--- create endpoint on third replica node if exist
DECLARE @sec3 varchar(120) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 2 ROWS FETCH NEXT 1 ROWS ONLY);

:r $(TEMP)\sec3.temp

IF @sec3 IS NOT NULL EXEC 
	(N'USE [master]

    CREATE ENDPOINT [Hadr_endpoint] 
        AS TCP (LISTENER_PORT = 5022)
        FOR DATA_MIRRORING (ROLE = ALL, ENCRYPTION = REQUIRED ALGORITHM AES)

    IF (SELECT state FROM sys.endpoints WHERE name = N''Hadr_endpoint'') <> 0
    BEGIN
        ALTER ENDPOINT [Hadr_endpoint] STATE = STARTED
    END

    IF EXISTS(SELECT * FROM sys.server_event_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER WITH (STARTUP_STATE=ON);
    END
    IF NOT EXISTS(SELECT * FROM sys.dm_xe_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER STATE=START;
    END')

GO

--- create endpoint on fourth replica node if exist
DECLARE @sec4 varchar(120) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 3 ROWS FETCH NEXT 1 ROWS ONLY);

:r $(TEMP)\sec4.temp

IF @sec4 IS NOT NULL EXEC 
	(N'USE [master]

    CREATE ENDPOINT [Hadr_endpoint] 
        AS TCP (LISTENER_PORT = 5022)
        FOR DATA_MIRRORING (ROLE = ALL, ENCRYPTION = REQUIRED ALGORITHM AES)

    IF (SELECT state FROM sys.endpoints WHERE name = N''Hadr_endpoint'') <> 0
    BEGIN
        ALTER ENDPOINT [Hadr_endpoint] STATE = STARTED
    END

    IF EXISTS(SELECT * FROM sys.server_event_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER WITH (STARTUP_STATE=ON);
    END
    IF NOT EXISTS(SELECT * FROM sys.dm_xe_sessions WHERE name=''AlwaysOn_health'')
    BEGIN
    ALTER EVENT SESSION [AlwaysOn_health] ON SERVER STATE=START;
    END')

GO

-- Define nodes
DECLARE @sec1 NVARCHAR(128) = (SELECT TOP 1 member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername);
DECLARE	@sec2 NVARCHAR(128) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 1 ROWS FETCH NEXT 1 ROWS ONLY);
DECLARE @sec3 NVARCHAR(128) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 2 ROWS FETCH NEXT 1 ROWS ONLY);
DECLARE @sec4 NVARCHAR(128) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 3 ROWS FETCH NEXT 1 ROWS ONLY);
DECLARE @AvailabilityGroupName NVARCHAR(128) = 'MyAG';
DECLARE @DatabaseName NVARCHAR(128) = 'MyDB'; 

DECLARE @tsql2 nvarchar(max) 

SET @tsql2 = 
    N'
    CREATE AVAILABILITY GROUP ' + QUOTENAME(@AvailabilityGroupName) + N'
    WITH (AUTOMATED_BACKUP_PREFERENCE = SECONDARY,
    DB_FAILOVER = OFF,
    DTC_SUPPORT = NONE,
    REQUIRED_SYNCHRONIZED_SECONDARIES_TO_COMMIT = 0)
    FOR DATABASE ' + QUOTENAME(@DatabaseName) + N'
    REPLICA ON
        N''' + @@SERVERNAME + N''' WITH (
            ENDPOINT_URL = N''TCP://' + @@SERVERNAME + N':5022'',
            FAILOVER_MODE = AUTOMATIC,
            AVAILABILITY_MODE = SYNCHRONOUS_COMMIT,
            BACKUP_PRIORITY = 50, 
            SEEDING_MODE = AUTOMATIC, 
            SECONDARY_ROLE (ALLOW_CONNECTIONS = NO)),
        N''' + @sec1 + N''' WITH (
            ENDPOINT_URL = N''TCP://' + @sec1 + N':5022'',
            FAILOVER_MODE = AUTOMATIC,
            AVAILABILITY_MODE = SYNCHRONOUS_COMMIT,
            BACKUP_PRIORITY = 50, 
            SEEDING_MODE = AUTOMATIC, 
            SECONDARY_ROLE (ALLOW_CONNECTIONS = NO))
    '

IF @sec2 is not null SET @tsql2 = @tsql2 + 
		N', N''' + @sec2 + N''' WITH (
			ENDPOINT_URL = N''TCP://' + @sec2 + N':5022'',
			FAILOVER_MODE = AUTOMATIC,
			AVAILABILITY_MODE = SYNCHRONOUS_COMMIT,
			BACKUP_PRIORITY = 50, 
			SEEDING_MODE = AUTOMATIC, 
			SECONDARY_ROLE (ALLOW_CONNECTIONS = NO))
	'

IF @sec3 is not null SET @tsql2 = @tsql2 + 
		N', N''' + @sec3 + N''' WITH (
			ENDPOINT_URL = N''TCP://' + @sec3 + N':5022'',
			FAILOVER_MODE = AUTOMATIC,
			AVAILABILITY_MODE = ASYNCHRONOUS_COMMIT,
			BACKUP_PRIORITY = 50, 
			SEEDING_MODE = AUTOMATIC, 
			SECONDARY_ROLE (ALLOW_CONNECTIONS = NO))
	'

IF @sec4 is not null SET @tsql2 = @tsql2 + 
		N', N''' + @sec4 + N''' WITH (
			ENDPOINT_URL = N''TCP://' + @sec4 + N':5022'',
			FAILOVER_MODE = AUTOMATIC,
			AVAILABILITY_MODE = ASYNCHRONOUS_COMMIT,
			BACKUP_PRIORITY = 50, 
			SEEDING_MODE = AUTOMATIC, 
			SECONDARY_ROLE (ALLOW_CONNECTIONS = NO))'

SET @tsql2 = @tsql2 + ';'

-- now create the AG on primary
:r $(TEMP)\primary.temp
PRINT @tsql2;

-- Execute the dynamic SQL command
EXEC sp_executesql @tsql2;

GO

-- Join AG on first replica node
DECLARE @sec1 NVARCHAR(128) = (SELECT TOP 1 member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername);

:r $(TEMP)\sec1.temp

EXEC (N'ALTER AVAILABILITY GROUP [MyAG] JOIN; ALTER AVAILABILITY GROUP [MyAG] GRANT CREATE ANY DATABASE;')

GO

-- Join AG on second replica node
DECLARE	@sec2 NVARCHAR(128) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 1 ROWS FETCH NEXT 1 ROWS ONLY);

:r $(TEMP)\sec2.temp

IF @sec2 IS NOT NULL EXEC (N'ALTER AVAILABILITY GROUP [MyAG] JOIN; ALTER AVAILABILITY GROUP [MyAG] GRANT CREATE ANY DATABASE;')

GO

-- Join AG on third replica node
DECLARE @sec3 NVARCHAR(128) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 2 ROWS FETCH NEXT 1 ROWS ONLY);

:r $(TEMP)\sec3.temp

IF @sec3 IS NOT NULL EXEC (N'ALTER AVAILABILITY GROUP [MyAG] JOIN; ALTER AVAILABILITY GROUP [MyAG] GRANT CREATE ANY DATABASE;')

GO

-- Join AG on fourth replica node
DECLARE @sec4 NVARCHAR(128) = (SELECT member_name from master.sys.dm_hadr_cluster_members where member_name like 'sql-%' and member_name not like @@servername order by member_name OFFSET 3 ROWS FETCH NEXT 1 ROWS ONLY);

:r $(TEMP)\sec4.temp

IF @sec4 IS NOT NULL EXEC (N'ALTER AVAILABILITY GROUP [MyAG] JOIN; ALTER AVAILABILITY GROUP [MyAG] GRANT CREATE ANY DATABASE;')

GO
